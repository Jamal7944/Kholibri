<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Kholibri.Classes.MyThread API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Kholibri.Classes.MyThread</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import codecs, glob, shutil, threading, subprocess, os
from tkinter import messagebox
from SGBD.SGBD import *

from Classes import CreerFeuille
from Classes.ApplicationViews import *

exitFlag = 0

class myThread(threading.Thread):
    &#34;&#34;&#34;
    Cette classe permet la création des différents Threads\n
    Il y a 5 threads différents :
            \n- ThreadAppli                   : Le lancement de l&#39;application
            \n- ThreadPreVisualisation        : La génération et visualisation d&#39;un exercice
            \n- ThreadPrevisualisationFeuille : La génération et visualisation d&#39;une feuille de colle
            \n- ThreadLogCompilation          : Le lancement de la fenetre d&#39;affichage de la compilation d&#39;un exercice
            \n- WriteInLog                    : L&#39;affichage de la compilation d&#39;un exercice
    Afin de permettre cette dernière fonctionnalité,
    des méthodes ont été rajoutés afin de mimer le fonctionnement d&#39;un objet File de python
    &#34;&#34;&#34;

    def __init__(self, name, logWindow=None, pipeReader=None, enonceTemp=None, corrigeTemp=None, questionCours=None,template=None,auteur=None, etudiant=None):
        &#34;&#34;&#34;
        Constructeur de la classe
        
        Parameters
        ----------
        name : Chaque threads ont un nom, celui-ci
                     permet l&#39;identification du thread et ainsi, parmatrer le fonctionnement du thread
        logWindow : Paramètre nécessaire uniquement pour le Thread WriteInLog,
                          il permet d&#39;identifié la fenetre crée par le thread LogCompilation et de, ainsi, la modifier
        pipeReader : Paramètre nécessaire uniquement pour le Thread WriteInLog,
                           il permet d&#39;identifié la sortie de la commande de compilation et d&#39;en récupéré le contenu
        enonceTemp
        corrigeTemp
        questionCours
        template
        auteur
        etudiant
        &#34;&#34;&#34;
        # dans tous les cas, on initialise le thread et le nom du thread
        threading.Thread.__init__(self)
        self.name = name
        # si le thread est celui de création de la fenetre de log,
        # on a besoin d&#39;attribut pour mimer le fonctionnement d&#39;un fichier
        if self.name == &#34;ThreadLogCompilation&#34;:
            self.fdRead, self.fdWrite = os.pipe()
            self.pipeReader = os.fdopen(self.fdRead)
            self.daemon = False
        # si le thread est celui d&#39;écriture de log, on récupère la fenetre et le reader
        if self.name == &#34;WriteInLog&#34;:
            self.logWindow = logWindow
            self.pipeReader = pipeReader
        self.enonceTemp = enonceTemp
        self.corrigeTemp = corrigeTemp
        self.questionCours = questionCours
        self.template = template
        self.auteur = auteur
        self.etudiant = etudiant

    def run(self):
        &#34;&#34;&#34;
        méthode qui est appelée pour lancer un thread
        elle s&#39;occupe de renvoyer vers la bonne méthode selon le nom du thread
        &#34;&#34;&#34;

        if self.name == &#34;ThreadAppli&#34;:
            self.application = ApplicationViews()
            self.creation_temp()
            self.application.protocol(&#34;WM_DELETE_WINDOW&#34;, self.on_closing)
            self.application.mainloop()
        if self.name == &#34;ThreadPreVisualisationStyle&#34;:
            self.PrevisualisationStyle()
        if self.name == &#34;ThreadPrevisualisationFeuille&#34;:
            self.PrevisualtisationFeuille()
        if self.name == &#34;ThreadLogCompilation&#34;:
            self.LogCompilation()
        if self.name == &#34;WriteInLog&#34;:
            self.WriteInLog()
        if self.name == &#34;ThreadPrevisualisationExo&#34;:
            self.PrevisualisationExo()

    def PrevisualisationStyle(self):
        &#34;&#34;&#34;
        Fonction appelé lorsque le thread est ThreadPreVisualisation
        Il permet la compilation et l&#39;affichage d&#39;un exercice
        Ce Thread crée et appel le thread ThreadLogCompilation pour donner des informations à l&#39;utilisateur
        IMPORTANT : toute écriture dans un fichier tex pour qu&#39;il soit compilé devra être en encodé UTF-8
        &#34;&#34;&#34;
         # pour visualiser la feuille de style d&#39;un nouvel utilisateur

        file = open(&#34;temp/test.tex&#34;, &#34;wb&#34;)
        style = self.template.splitlines()
        for line in style :
            if &#34;\\end{document}&#34; not in line:
                file.write(line.encode(&#39;utf-8&#39;))
                file.write(&#34;\n&#34;.encode(&#39;utf-8&#39;))

        file.write((&#34;\n&#34; + r&#34;\begin{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
        file.write(self.enonceTemp.encode(&#39;utf-8&#39;))

        file.write((&#34;\n&#34; + r&#34;\end{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))

        file.write((&#34;\n&#34; + &#34;\n&#34; + r&#34;\begin{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
        file.write(self.corrigeTemp.encode(&#39;utf-8&#39;))
        file.write((&#34;\n&#34; + r&#34;\end{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
        file.write((&#34;\end{document}&#34;).encode(&#39;utf-8&#39;))

        file.close()
        # on crée le thread de log et on le démarre
        log = myThread(&#34;ThreadLogCompilation&#34;)
        log.start()
        # ce thread peut être interprété comme fichier de sortie de commande
        # on peut donc spécifier a subprocess.Popen,
        # qui s&#39;occupe de compiler le fichier latex via la commande de shell pdflatex,
        # que le fichier de sortie est le thread ThreadLogCompilation
        process = subprocess.Popen(
            [&#39;pdflatex&#39;, &#39;temp/test.tex&#39;], stdout=log,stderr=log)
        # on attend la fin de la compilation
        # (par défaut subprocess.Popen renvoi dès le lancement de la commande)
        process.wait()

        # on ferme le &#34;fichier&#34;
        os.close(log.fdWrite)
        # et on attend la fin du thread
        log.join()

        shutil.move(&#39;test.pdf&#39;, &#39;temp/test.pdf&#39;)
        list_of_files = glob.glob(r&#39;temp/*.pdf&#39;)
        latest_file = max(list_of_files, key=os.path.getctime)

        os.remove(&#34;test.aux&#34;)
        os.remove(&#34;test.log&#34;)
        os.remove(&#34;test.out&#34;)
        # os.remove(&#34;test.toc&#34;)

        self.open_file(latest_file)


    def PrevisualisationExo(self):
        &#34;&#34;&#34;
        Fonction appelé lorsque le thread est ThreadPreVisualisation
        Il permet la compilation et l&#39;affichage d&#39;un exercice
        Ce Thread crée et appel le thread ThreadLogCompilation pour donner des informations à l&#39;utilisateur
        IMPORTANT : toute écriture dans un fichier tex pour qu&#39;il soit compilé devra être en encodé UTF-8
        &#34;&#34;&#34;
         # pour visualiser la feuille de style d&#39;un nouvel utilisateur

        file = open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/testexo.tex&#34;, &#34;wb&#34;)
        with codecs.open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/style.tex&#34;, encoding=&#34;utf-8&#34;, errors=&#39;replace&#39;) as filestyle:
            contenu = filestyle.readlines()
            for line in contenu :
                if &#34;\\end{document}&#34; not in line :
                    file.write(line.encode(&#39;utf-8&#39;))
                else :
                    file.write((&#34;\n&#34; + r&#34;\begin{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                    file.write(self.enonceTemp.encode(&#39;utf-8&#39;))
                    file.write((&#34;\n&#34; + r&#34;\end{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                    file.write((&#34;\n&#34; + &#34;\n&#34; + r&#34;\begin{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                    file.write(self.corrigeTemp.encode(&#39;utf-8&#39;))
                    file.write((&#34;\n&#34; + r&#34;\end{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                    file.write(line.encode(&#39;utf-8&#39;))

        file.close()
        # on crée le thread de log et on le démarre
        log = myThread(&#34;ThreadLogCompilation&#34;)
        log.start()
        # ce thread peut être interprété comme fichier de sortie de commande
        # on peut donc spécifier a subprocess.Popen,
        # qui s&#39;occupe de compiler le fichier latex via la commande de shell pdflatex,
        # que le fichier de sortie est le thread ThreadLogCompilation
        process = subprocess.Popen(
            [&#39;pdflatex&#39;, &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/testexo.tex&#34;], stdout=log,stderr=log)
        # on attend la fin de la compilation
        # (par défaut subprocess.Popen renvoi dès le lancement de la commande)
        process.wait()

        # on ferme le &#34;fichier&#34;
        os.close(log.fdWrite)
        # et on attend la fin du thread
        log.join()

        shutil.move(&#39;testexo.pdf&#39;,&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/testexo.pdf&#34;)
        list_of_files = glob.glob(r&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/*.pdf&#34;)
        latest_file = max(list_of_files, key=os.path.getctime)

        os.remove(&#34;testexo.aux&#34;)
        os.remove(&#34;testexo.log&#34;)
        os.remove(&#34;testexo.out&#34;)
        # os.remove(&#34;testexo.toc&#34;)

        self.open_file(latest_file)

    def PrevisualtisationFeuille(self):
        if (self.etudiant):
            nom, prenom = self.etudiant
        else:
            nom, prenom = &#34;temp&#34;, &#34;temp&#34;
        temp = open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.tex&#34;, &#34;wb&#34;)
        with codecs.open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/style.tex&#34;, encoding=&#34;utf-8&#34;, errors=&#39;replace&#39;) as fichier:
            contenu = fichier.readlines()
            write = True
            for k in contenu:
                if write:
                    if k.startswith(r&#39;\begin{cours}&#39;):
                        if self.questionCours != &#34;&#34;:
                            temp.write(k.encode(&#39;utf-8&#39;))
                            temp.write(self.questionCours.encode(&#39;utf-8&#39;))
                        write = False
                    else:
                        if &#34;\\end{document}&#34; not in k:
                            temp.write(k.encode(&#39;utf-8&#39;))
                else:
                    if k.startswith(r&#39;\end{cours}&#39;):
                        if self.questionCours != &#34;&#34;:
                            temp.write(k.encode(&#39;utf-8&#39;))
                        write = True

            temp.write((&#39;\n&#39;).encode(&#39;utf-8&#39;))

           # temp.write((r&#34;\reversemarginpar&#34;).encode(&#39;utf-8&#39;))

            for exoId in CreerFeuille.listeFinale.get(self.etudiant).keys():
                exo = [exoId,
                       CreerFeuille.listeFinale.get(self.etudiant).get(exoId).get(&#34;exo&#34;),
                       CreerFeuille.listeFinale.get(self.etudiant).get(exoId).get(&#34;sol&#34;)]

                temp.write((&#34;\n&#34; + r&#34;\begin{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
               # temp.write((&#34;\n&#34; + r&#34;\marginpar{\small{\vspace{\baselineskip} \hspace{0.05cm} \textcolor{rouge}{ID exo :}} &#34; + str(
                #               exo[0]) + &#34;}&#34; +&#34;\n&#34;).encode(&#39;utf-8&#39;))
                temp.write(exo[1].encode(&#39;utf-8&#39;))

                temp.write((&#34;\n&#34; + r&#34;\end{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))

                temp.write((&#34;\n&#34; + &#34;\n&#34; + r&#34;\begin{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                temp.write(exo[2].encode(&#39;utf-8&#39;))
                temp.write((&#34;\n&#34; + r&#34;\end{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))

            temp.write((&#34;\end{document}&#34;).encode(&#39;utf-8&#39;))
            temp.close()

            output = subprocess.check_output([&#34;pdflatex&#34;, &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.tex&#34;])
            try:
                shutil.move(f&#39;{nom}_{prenom}.pdf&#39;, &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.pdf&#34;)
            except FileNotFoundError as e:
                messagebox.showerror(title=&#34;Erreur lors de la compilation&#34;,
                                     message=&#34;pdflatex est nécessaire à la compilation des fichers\nVeuillez l&#39;installer avant de continuer&#34;)
            else:
                # création d&#39;un pop-up dans le cas où c&#39;est le dernier pdf générer
                list_of_files = glob.glob(r&#34;SGBD/utilisateurs/&#34; + self.auteur + &#34;/temp/*.pdf&#34;)
                latest_file = max(list_of_files, key=os.path.getctime)
                if latest_file == &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.pdf&#34;:
                    messagebox.showinfo(title=&#34;Veuillez patienter, compilation en cours&#34;,
                                        message=&#34;La prévisualisation s&#39;ouvrira d&#39;elle même&#34;)

                os.remove(f&#34;{nom}_{prenom}.aux&#34;)
                os.remove(f&#34;{nom}_{prenom}.log&#34;)
                os.remove(f&#34;{nom}_{prenom}.out&#34;)
                self.open_file(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.pdf&#34;)


    def LogCompilation(self):
        logWindow = Tk()
        logWindow.title = &#34;Compilation en Cours&#34;
        logText = Text(logWindow, bg=&#34;#E5E5E5&#34;)
        logText.pack()
        finishButton = Button(logWindow, text=&#34;Afficher l&#39;exercice&#34;, state=&#39;disabled&#39;)
        finishButton.pack()
        writer = myThread(&#34;WriteInLog&#34;, logWindow, self.pipeReader)
        writer.start()
        logWindow.mainloop()
        writer.join()
        self.pipeReader.close()

    def WriteInLog(self):
        logText = self.logWindow.winfo_children()[0]
        finishButton = self.logWindow.winfo_children()[1]
        for line in iter(self.pipeReader.readline, &#39;&#39;):
            logText.configure(state=&#39;normal&#39;,fg=&#39;red&#39;)
            logText.insert(&#39;end&#39;, line)
            logText.see(&#39;end&#39;)
            logText.configure(state=&#39;disabled&#39;)
        self.pipeReader.close()
        finishButton.configure(command=self.logWindow.destroy, state=&#39;normal&#39;)

    def open_file(self, filename):
        if &#34;win&#34; in sys.platform.lower():
            os.startfile(filename)
        else:
            opener = &#34;open&#34; if sys.platform == &#34;darwin&#34; else &#34;xdg-open&#34;
            subprocess.call([opener, filename])

    def fileno(self):
        &#34;&#34;&#34;Return the write file descriptor of the pipe
      &#34;&#34;&#34;
        return self.fdWrite

    def creation_temp(self):
        try:
            if not os.path.exists(&#34;temp&#34;):
                os.makedirs(&#39;temp&#39;)
        except:
            messagebox.showerror(&#34;Impossible de créer le dossier temp. Essayez de créer un dossier temp.&#34;)
            return

    def on_closing(self):
        try:
            shutil.rmtree(&#39;./temp&#39;, ignore_errors=True)
        except:
            print(&#34;Impossible de supprimer le dossier temp.&#34;)
        self.application.destroy()
        exit()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Kholibri.Classes.MyThread.myThread"><code class="flex name class">
<span>class <span class="ident">myThread</span></span>
<span>(</span><span>name, logWindow=None, pipeReader=None, enonceTemp=None, corrigeTemp=None, questionCours=None, template=None, auteur=None, etudiant=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Cette classe permet la création des différents Threads</p>
<pre><code>Il y a 5 threads différents :
</code></pre>
<ul>
<li>
<p>ThreadAppli
: Le lancement de l'application</p>
</li>
<li>
<p>ThreadPreVisualisation
: La génération et visualisation d'un exercice</p>
</li>
<li>
<p>ThreadPrevisualisationFeuille : La génération et visualisation d'une feuille de colle</p>
</li>
<li>
<p>ThreadLogCompilation
: Le lancement de la fenetre d'affichage de la compilation d'un exercice</p>
</li>
<li>
<p>WriteInLog
: L'affichage de la compilation d'un exercice
Afin de permettre cette dernière fonctionnalité,
des méthodes ont été rajoutés afin de mimer le fonctionnement d'un objet File de python</p>
</li>
</ul>
<p>Constructeur de la classe</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Chaque threads ont un nom, celui-ci</code></dt>
<dd>permet l'identification du thread et ainsi, parmatrer le fonctionnement du thread</dd>
<dt><strong><code>logWindow</code></strong> :&ensp;<code>Paramètre nécessaire uniquement pour le Thread WriteInLog,</code></dt>
<dd>il permet d'identifié la fenetre crée par le thread LogCompilation et de, ainsi, la modifier</dd>
<dt><strong><code>pipeReader</code></strong> :&ensp;<code>Paramètre nécessaire uniquement pour le Thread WriteInLog,</code></dt>
<dd>il permet d'identifié la sortie de la commande de compilation et d'en récupéré le contenu</dd>
<dt><strong><code>enonceTemp</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>corrigeTemp</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>questionCours</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>template</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>auteur</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>etudiant</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class myThread(threading.Thread):
    &#34;&#34;&#34;
    Cette classe permet la création des différents Threads\n
    Il y a 5 threads différents :
            \n- ThreadAppli                   : Le lancement de l&#39;application
            \n- ThreadPreVisualisation        : La génération et visualisation d&#39;un exercice
            \n- ThreadPrevisualisationFeuille : La génération et visualisation d&#39;une feuille de colle
            \n- ThreadLogCompilation          : Le lancement de la fenetre d&#39;affichage de la compilation d&#39;un exercice
            \n- WriteInLog                    : L&#39;affichage de la compilation d&#39;un exercice
    Afin de permettre cette dernière fonctionnalité,
    des méthodes ont été rajoutés afin de mimer le fonctionnement d&#39;un objet File de python
    &#34;&#34;&#34;

    def __init__(self, name, logWindow=None, pipeReader=None, enonceTemp=None, corrigeTemp=None, questionCours=None,template=None,auteur=None, etudiant=None):
        &#34;&#34;&#34;
        Constructeur de la classe
        
        Parameters
        ----------
        name : Chaque threads ont un nom, celui-ci
                     permet l&#39;identification du thread et ainsi, parmatrer le fonctionnement du thread
        logWindow : Paramètre nécessaire uniquement pour le Thread WriteInLog,
                          il permet d&#39;identifié la fenetre crée par le thread LogCompilation et de, ainsi, la modifier
        pipeReader : Paramètre nécessaire uniquement pour le Thread WriteInLog,
                           il permet d&#39;identifié la sortie de la commande de compilation et d&#39;en récupéré le contenu
        enonceTemp
        corrigeTemp
        questionCours
        template
        auteur
        etudiant
        &#34;&#34;&#34;
        # dans tous les cas, on initialise le thread et le nom du thread
        threading.Thread.__init__(self)
        self.name = name
        # si le thread est celui de création de la fenetre de log,
        # on a besoin d&#39;attribut pour mimer le fonctionnement d&#39;un fichier
        if self.name == &#34;ThreadLogCompilation&#34;:
            self.fdRead, self.fdWrite = os.pipe()
            self.pipeReader = os.fdopen(self.fdRead)
            self.daemon = False
        # si le thread est celui d&#39;écriture de log, on récupère la fenetre et le reader
        if self.name == &#34;WriteInLog&#34;:
            self.logWindow = logWindow
            self.pipeReader = pipeReader
        self.enonceTemp = enonceTemp
        self.corrigeTemp = corrigeTemp
        self.questionCours = questionCours
        self.template = template
        self.auteur = auteur
        self.etudiant = etudiant

    def run(self):
        &#34;&#34;&#34;
        méthode qui est appelée pour lancer un thread
        elle s&#39;occupe de renvoyer vers la bonne méthode selon le nom du thread
        &#34;&#34;&#34;

        if self.name == &#34;ThreadAppli&#34;:
            self.application = ApplicationViews()
            self.creation_temp()
            self.application.protocol(&#34;WM_DELETE_WINDOW&#34;, self.on_closing)
            self.application.mainloop()
        if self.name == &#34;ThreadPreVisualisationStyle&#34;:
            self.PrevisualisationStyle()
        if self.name == &#34;ThreadPrevisualisationFeuille&#34;:
            self.PrevisualtisationFeuille()
        if self.name == &#34;ThreadLogCompilation&#34;:
            self.LogCompilation()
        if self.name == &#34;WriteInLog&#34;:
            self.WriteInLog()
        if self.name == &#34;ThreadPrevisualisationExo&#34;:
            self.PrevisualisationExo()

    def PrevisualisationStyle(self):
        &#34;&#34;&#34;
        Fonction appelé lorsque le thread est ThreadPreVisualisation
        Il permet la compilation et l&#39;affichage d&#39;un exercice
        Ce Thread crée et appel le thread ThreadLogCompilation pour donner des informations à l&#39;utilisateur
        IMPORTANT : toute écriture dans un fichier tex pour qu&#39;il soit compilé devra être en encodé UTF-8
        &#34;&#34;&#34;
         # pour visualiser la feuille de style d&#39;un nouvel utilisateur

        file = open(&#34;temp/test.tex&#34;, &#34;wb&#34;)
        style = self.template.splitlines()
        for line in style :
            if &#34;\\end{document}&#34; not in line:
                file.write(line.encode(&#39;utf-8&#39;))
                file.write(&#34;\n&#34;.encode(&#39;utf-8&#39;))

        file.write((&#34;\n&#34; + r&#34;\begin{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
        file.write(self.enonceTemp.encode(&#39;utf-8&#39;))

        file.write((&#34;\n&#34; + r&#34;\end{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))

        file.write((&#34;\n&#34; + &#34;\n&#34; + r&#34;\begin{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
        file.write(self.corrigeTemp.encode(&#39;utf-8&#39;))
        file.write((&#34;\n&#34; + r&#34;\end{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
        file.write((&#34;\end{document}&#34;).encode(&#39;utf-8&#39;))

        file.close()
        # on crée le thread de log et on le démarre
        log = myThread(&#34;ThreadLogCompilation&#34;)
        log.start()
        # ce thread peut être interprété comme fichier de sortie de commande
        # on peut donc spécifier a subprocess.Popen,
        # qui s&#39;occupe de compiler le fichier latex via la commande de shell pdflatex,
        # que le fichier de sortie est le thread ThreadLogCompilation
        process = subprocess.Popen(
            [&#39;pdflatex&#39;, &#39;temp/test.tex&#39;], stdout=log,stderr=log)
        # on attend la fin de la compilation
        # (par défaut subprocess.Popen renvoi dès le lancement de la commande)
        process.wait()

        # on ferme le &#34;fichier&#34;
        os.close(log.fdWrite)
        # et on attend la fin du thread
        log.join()

        shutil.move(&#39;test.pdf&#39;, &#39;temp/test.pdf&#39;)
        list_of_files = glob.glob(r&#39;temp/*.pdf&#39;)
        latest_file = max(list_of_files, key=os.path.getctime)

        os.remove(&#34;test.aux&#34;)
        os.remove(&#34;test.log&#34;)
        os.remove(&#34;test.out&#34;)
        # os.remove(&#34;test.toc&#34;)

        self.open_file(latest_file)


    def PrevisualisationExo(self):
        &#34;&#34;&#34;
        Fonction appelé lorsque le thread est ThreadPreVisualisation
        Il permet la compilation et l&#39;affichage d&#39;un exercice
        Ce Thread crée et appel le thread ThreadLogCompilation pour donner des informations à l&#39;utilisateur
        IMPORTANT : toute écriture dans un fichier tex pour qu&#39;il soit compilé devra être en encodé UTF-8
        &#34;&#34;&#34;
         # pour visualiser la feuille de style d&#39;un nouvel utilisateur

        file = open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/testexo.tex&#34;, &#34;wb&#34;)
        with codecs.open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/style.tex&#34;, encoding=&#34;utf-8&#34;, errors=&#39;replace&#39;) as filestyle:
            contenu = filestyle.readlines()
            for line in contenu :
                if &#34;\\end{document}&#34; not in line :
                    file.write(line.encode(&#39;utf-8&#39;))
                else :
                    file.write((&#34;\n&#34; + r&#34;\begin{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                    file.write(self.enonceTemp.encode(&#39;utf-8&#39;))
                    file.write((&#34;\n&#34; + r&#34;\end{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                    file.write((&#34;\n&#34; + &#34;\n&#34; + r&#34;\begin{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                    file.write(self.corrigeTemp.encode(&#39;utf-8&#39;))
                    file.write((&#34;\n&#34; + r&#34;\end{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                    file.write(line.encode(&#39;utf-8&#39;))

        file.close()
        # on crée le thread de log et on le démarre
        log = myThread(&#34;ThreadLogCompilation&#34;)
        log.start()
        # ce thread peut être interprété comme fichier de sortie de commande
        # on peut donc spécifier a subprocess.Popen,
        # qui s&#39;occupe de compiler le fichier latex via la commande de shell pdflatex,
        # que le fichier de sortie est le thread ThreadLogCompilation
        process = subprocess.Popen(
            [&#39;pdflatex&#39;, &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/testexo.tex&#34;], stdout=log,stderr=log)
        # on attend la fin de la compilation
        # (par défaut subprocess.Popen renvoi dès le lancement de la commande)
        process.wait()

        # on ferme le &#34;fichier&#34;
        os.close(log.fdWrite)
        # et on attend la fin du thread
        log.join()

        shutil.move(&#39;testexo.pdf&#39;,&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/testexo.pdf&#34;)
        list_of_files = glob.glob(r&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/*.pdf&#34;)
        latest_file = max(list_of_files, key=os.path.getctime)

        os.remove(&#34;testexo.aux&#34;)
        os.remove(&#34;testexo.log&#34;)
        os.remove(&#34;testexo.out&#34;)
        # os.remove(&#34;testexo.toc&#34;)

        self.open_file(latest_file)

    def PrevisualtisationFeuille(self):
        if (self.etudiant):
            nom, prenom = self.etudiant
        else:
            nom, prenom = &#34;temp&#34;, &#34;temp&#34;
        temp = open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.tex&#34;, &#34;wb&#34;)
        with codecs.open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/style.tex&#34;, encoding=&#34;utf-8&#34;, errors=&#39;replace&#39;) as fichier:
            contenu = fichier.readlines()
            write = True
            for k in contenu:
                if write:
                    if k.startswith(r&#39;\begin{cours}&#39;):
                        if self.questionCours != &#34;&#34;:
                            temp.write(k.encode(&#39;utf-8&#39;))
                            temp.write(self.questionCours.encode(&#39;utf-8&#39;))
                        write = False
                    else:
                        if &#34;\\end{document}&#34; not in k:
                            temp.write(k.encode(&#39;utf-8&#39;))
                else:
                    if k.startswith(r&#39;\end{cours}&#39;):
                        if self.questionCours != &#34;&#34;:
                            temp.write(k.encode(&#39;utf-8&#39;))
                        write = True

            temp.write((&#39;\n&#39;).encode(&#39;utf-8&#39;))

           # temp.write((r&#34;\reversemarginpar&#34;).encode(&#39;utf-8&#39;))

            for exoId in CreerFeuille.listeFinale.get(self.etudiant).keys():
                exo = [exoId,
                       CreerFeuille.listeFinale.get(self.etudiant).get(exoId).get(&#34;exo&#34;),
                       CreerFeuille.listeFinale.get(self.etudiant).get(exoId).get(&#34;sol&#34;)]

                temp.write((&#34;\n&#34; + r&#34;\begin{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
               # temp.write((&#34;\n&#34; + r&#34;\marginpar{\small{\vspace{\baselineskip} \hspace{0.05cm} \textcolor{rouge}{ID exo :}} &#34; + str(
                #               exo[0]) + &#34;}&#34; +&#34;\n&#34;).encode(&#39;utf-8&#39;))
                temp.write(exo[1].encode(&#39;utf-8&#39;))

                temp.write((&#34;\n&#34; + r&#34;\end{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))

                temp.write((&#34;\n&#34; + &#34;\n&#34; + r&#34;\begin{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                temp.write(exo[2].encode(&#39;utf-8&#39;))
                temp.write((&#34;\n&#34; + r&#34;\end{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))

            temp.write((&#34;\end{document}&#34;).encode(&#39;utf-8&#39;))
            temp.close()

            output = subprocess.check_output([&#34;pdflatex&#34;, &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.tex&#34;])
            try:
                shutil.move(f&#39;{nom}_{prenom}.pdf&#39;, &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.pdf&#34;)
            except FileNotFoundError as e:
                messagebox.showerror(title=&#34;Erreur lors de la compilation&#34;,
                                     message=&#34;pdflatex est nécessaire à la compilation des fichers\nVeuillez l&#39;installer avant de continuer&#34;)
            else:
                # création d&#39;un pop-up dans le cas où c&#39;est le dernier pdf générer
                list_of_files = glob.glob(r&#34;SGBD/utilisateurs/&#34; + self.auteur + &#34;/temp/*.pdf&#34;)
                latest_file = max(list_of_files, key=os.path.getctime)
                if latest_file == &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.pdf&#34;:
                    messagebox.showinfo(title=&#34;Veuillez patienter, compilation en cours&#34;,
                                        message=&#34;La prévisualisation s&#39;ouvrira d&#39;elle même&#34;)

                os.remove(f&#34;{nom}_{prenom}.aux&#34;)
                os.remove(f&#34;{nom}_{prenom}.log&#34;)
                os.remove(f&#34;{nom}_{prenom}.out&#34;)
                self.open_file(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.pdf&#34;)


    def LogCompilation(self):
        logWindow = Tk()
        logWindow.title = &#34;Compilation en Cours&#34;
        logText = Text(logWindow, bg=&#34;#E5E5E5&#34;)
        logText.pack()
        finishButton = Button(logWindow, text=&#34;Afficher l&#39;exercice&#34;, state=&#39;disabled&#39;)
        finishButton.pack()
        writer = myThread(&#34;WriteInLog&#34;, logWindow, self.pipeReader)
        writer.start()
        logWindow.mainloop()
        writer.join()
        self.pipeReader.close()

    def WriteInLog(self):
        logText = self.logWindow.winfo_children()[0]
        finishButton = self.logWindow.winfo_children()[1]
        for line in iter(self.pipeReader.readline, &#39;&#39;):
            logText.configure(state=&#39;normal&#39;,fg=&#39;red&#39;)
            logText.insert(&#39;end&#39;, line)
            logText.see(&#39;end&#39;)
            logText.configure(state=&#39;disabled&#39;)
        self.pipeReader.close()
        finishButton.configure(command=self.logWindow.destroy, state=&#39;normal&#39;)

    def open_file(self, filename):
        if &#34;win&#34; in sys.platform.lower():
            os.startfile(filename)
        else:
            opener = &#34;open&#34; if sys.platform == &#34;darwin&#34; else &#34;xdg-open&#34;
            subprocess.call([opener, filename])

    def fileno(self):
        &#34;&#34;&#34;Return the write file descriptor of the pipe
      &#34;&#34;&#34;
        return self.fdWrite

    def creation_temp(self):
        try:
            if not os.path.exists(&#34;temp&#34;):
                os.makedirs(&#39;temp&#39;)
        except:
            messagebox.showerror(&#34;Impossible de créer le dossier temp. Essayez de créer un dossier temp.&#34;)
            return

    def on_closing(self):
        try:
            shutil.rmtree(&#39;./temp&#39;, ignore_errors=True)
        except:
            print(&#34;Impossible de supprimer le dossier temp.&#34;)
        self.application.destroy()
        exit()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Kholibri.Classes.MyThread.myThread.LogCompilation"><code class="name flex">
<span>def <span class="ident">LogCompilation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LogCompilation(self):
    logWindow = Tk()
    logWindow.title = &#34;Compilation en Cours&#34;
    logText = Text(logWindow, bg=&#34;#E5E5E5&#34;)
    logText.pack()
    finishButton = Button(logWindow, text=&#34;Afficher l&#39;exercice&#34;, state=&#39;disabled&#39;)
    finishButton.pack()
    writer = myThread(&#34;WriteInLog&#34;, logWindow, self.pipeReader)
    writer.start()
    logWindow.mainloop()
    writer.join()
    self.pipeReader.close()</code></pre>
</details>
</dd>
<dt id="Kholibri.Classes.MyThread.myThread.PrevisualisationExo"><code class="name flex">
<span>def <span class="ident">PrevisualisationExo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction appelé lorsque le thread est ThreadPreVisualisation
Il permet la compilation et l'affichage d'un exercice
Ce Thread crée et appel le thread ThreadLogCompilation pour donner des informations à l'utilisateur
IMPORTANT : toute écriture dans un fichier tex pour qu'il soit compilé devra être en encodé UTF-8</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PrevisualisationExo(self):
    &#34;&#34;&#34;
    Fonction appelé lorsque le thread est ThreadPreVisualisation
    Il permet la compilation et l&#39;affichage d&#39;un exercice
    Ce Thread crée et appel le thread ThreadLogCompilation pour donner des informations à l&#39;utilisateur
    IMPORTANT : toute écriture dans un fichier tex pour qu&#39;il soit compilé devra être en encodé UTF-8
    &#34;&#34;&#34;
     # pour visualiser la feuille de style d&#39;un nouvel utilisateur

    file = open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/testexo.tex&#34;, &#34;wb&#34;)
    with codecs.open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/style.tex&#34;, encoding=&#34;utf-8&#34;, errors=&#39;replace&#39;) as filestyle:
        contenu = filestyle.readlines()
        for line in contenu :
            if &#34;\\end{document}&#34; not in line :
                file.write(line.encode(&#39;utf-8&#39;))
            else :
                file.write((&#34;\n&#34; + r&#34;\begin{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                file.write(self.enonceTemp.encode(&#39;utf-8&#39;))
                file.write((&#34;\n&#34; + r&#34;\end{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                file.write((&#34;\n&#34; + &#34;\n&#34; + r&#34;\begin{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                file.write(self.corrigeTemp.encode(&#39;utf-8&#39;))
                file.write((&#34;\n&#34; + r&#34;\end{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
                file.write(line.encode(&#39;utf-8&#39;))

    file.close()
    # on crée le thread de log et on le démarre
    log = myThread(&#34;ThreadLogCompilation&#34;)
    log.start()
    # ce thread peut être interprété comme fichier de sortie de commande
    # on peut donc spécifier a subprocess.Popen,
    # qui s&#39;occupe de compiler le fichier latex via la commande de shell pdflatex,
    # que le fichier de sortie est le thread ThreadLogCompilation
    process = subprocess.Popen(
        [&#39;pdflatex&#39;, &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/testexo.tex&#34;], stdout=log,stderr=log)
    # on attend la fin de la compilation
    # (par défaut subprocess.Popen renvoi dès le lancement de la commande)
    process.wait()

    # on ferme le &#34;fichier&#34;
    os.close(log.fdWrite)
    # et on attend la fin du thread
    log.join()

    shutil.move(&#39;testexo.pdf&#39;,&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/testexo.pdf&#34;)
    list_of_files = glob.glob(r&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/*.pdf&#34;)
    latest_file = max(list_of_files, key=os.path.getctime)

    os.remove(&#34;testexo.aux&#34;)
    os.remove(&#34;testexo.log&#34;)
    os.remove(&#34;testexo.out&#34;)
    # os.remove(&#34;testexo.toc&#34;)

    self.open_file(latest_file)</code></pre>
</details>
</dd>
<dt id="Kholibri.Classes.MyThread.myThread.PrevisualisationStyle"><code class="name flex">
<span>def <span class="ident">PrevisualisationStyle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fonction appelé lorsque le thread est ThreadPreVisualisation
Il permet la compilation et l'affichage d'un exercice
Ce Thread crée et appel le thread ThreadLogCompilation pour donner des informations à l'utilisateur
IMPORTANT : toute écriture dans un fichier tex pour qu'il soit compilé devra être en encodé UTF-8</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PrevisualisationStyle(self):
    &#34;&#34;&#34;
    Fonction appelé lorsque le thread est ThreadPreVisualisation
    Il permet la compilation et l&#39;affichage d&#39;un exercice
    Ce Thread crée et appel le thread ThreadLogCompilation pour donner des informations à l&#39;utilisateur
    IMPORTANT : toute écriture dans un fichier tex pour qu&#39;il soit compilé devra être en encodé UTF-8
    &#34;&#34;&#34;
     # pour visualiser la feuille de style d&#39;un nouvel utilisateur

    file = open(&#34;temp/test.tex&#34;, &#34;wb&#34;)
    style = self.template.splitlines()
    for line in style :
        if &#34;\\end{document}&#34; not in line:
            file.write(line.encode(&#39;utf-8&#39;))
            file.write(&#34;\n&#34;.encode(&#39;utf-8&#39;))

    file.write((&#34;\n&#34; + r&#34;\begin{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
    file.write(self.enonceTemp.encode(&#39;utf-8&#39;))

    file.write((&#34;\n&#34; + r&#34;\end{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))

    file.write((&#34;\n&#34; + &#34;\n&#34; + r&#34;\begin{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
    file.write(self.corrigeTemp.encode(&#39;utf-8&#39;))
    file.write((&#34;\n&#34; + r&#34;\end{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
    file.write((&#34;\end{document}&#34;).encode(&#39;utf-8&#39;))

    file.close()
    # on crée le thread de log et on le démarre
    log = myThread(&#34;ThreadLogCompilation&#34;)
    log.start()
    # ce thread peut être interprété comme fichier de sortie de commande
    # on peut donc spécifier a subprocess.Popen,
    # qui s&#39;occupe de compiler le fichier latex via la commande de shell pdflatex,
    # que le fichier de sortie est le thread ThreadLogCompilation
    process = subprocess.Popen(
        [&#39;pdflatex&#39;, &#39;temp/test.tex&#39;], stdout=log,stderr=log)
    # on attend la fin de la compilation
    # (par défaut subprocess.Popen renvoi dès le lancement de la commande)
    process.wait()

    # on ferme le &#34;fichier&#34;
    os.close(log.fdWrite)
    # et on attend la fin du thread
    log.join()

    shutil.move(&#39;test.pdf&#39;, &#39;temp/test.pdf&#39;)
    list_of_files = glob.glob(r&#39;temp/*.pdf&#39;)
    latest_file = max(list_of_files, key=os.path.getctime)

    os.remove(&#34;test.aux&#34;)
    os.remove(&#34;test.log&#34;)
    os.remove(&#34;test.out&#34;)
    # os.remove(&#34;test.toc&#34;)

    self.open_file(latest_file)</code></pre>
</details>
</dd>
<dt id="Kholibri.Classes.MyThread.myThread.PrevisualtisationFeuille"><code class="name flex">
<span>def <span class="ident">PrevisualtisationFeuille</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PrevisualtisationFeuille(self):
    if (self.etudiant):
        nom, prenom = self.etudiant
    else:
        nom, prenom = &#34;temp&#34;, &#34;temp&#34;
    temp = open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.tex&#34;, &#34;wb&#34;)
    with codecs.open(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/style.tex&#34;, encoding=&#34;utf-8&#34;, errors=&#39;replace&#39;) as fichier:
        contenu = fichier.readlines()
        write = True
        for k in contenu:
            if write:
                if k.startswith(r&#39;\begin{cours}&#39;):
                    if self.questionCours != &#34;&#34;:
                        temp.write(k.encode(&#39;utf-8&#39;))
                        temp.write(self.questionCours.encode(&#39;utf-8&#39;))
                    write = False
                else:
                    if &#34;\\end{document}&#34; not in k:
                        temp.write(k.encode(&#39;utf-8&#39;))
            else:
                if k.startswith(r&#39;\end{cours}&#39;):
                    if self.questionCours != &#34;&#34;:
                        temp.write(k.encode(&#39;utf-8&#39;))
                    write = True

        temp.write((&#39;\n&#39;).encode(&#39;utf-8&#39;))

       # temp.write((r&#34;\reversemarginpar&#34;).encode(&#39;utf-8&#39;))

        for exoId in CreerFeuille.listeFinale.get(self.etudiant).keys():
            exo = [exoId,
                   CreerFeuille.listeFinale.get(self.etudiant).get(exoId).get(&#34;exo&#34;),
                   CreerFeuille.listeFinale.get(self.etudiant).get(exoId).get(&#34;sol&#34;)]

            temp.write((&#34;\n&#34; + r&#34;\begin{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
           # temp.write((&#34;\n&#34; + r&#34;\marginpar{\small{\vspace{\baselineskip} \hspace{0.05cm} \textcolor{rouge}{ID exo :}} &#34; + str(
            #               exo[0]) + &#34;}&#34; +&#34;\n&#34;).encode(&#39;utf-8&#39;))
            temp.write(exo[1].encode(&#39;utf-8&#39;))

            temp.write((&#34;\n&#34; + r&#34;\end{exo}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))

            temp.write((&#34;\n&#34; + &#34;\n&#34; + r&#34;\begin{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))
            temp.write(exo[2].encode(&#39;utf-8&#39;))
            temp.write((&#34;\n&#34; + r&#34;\end{sol}&#34; + &#34;\n&#34;).encode(&#39;utf-8&#39;))

        temp.write((&#34;\end{document}&#34;).encode(&#39;utf-8&#39;))
        temp.close()

        output = subprocess.check_output([&#34;pdflatex&#34;, &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.tex&#34;])
        try:
            shutil.move(f&#39;{nom}_{prenom}.pdf&#39;, &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.pdf&#34;)
        except FileNotFoundError as e:
            messagebox.showerror(title=&#34;Erreur lors de la compilation&#34;,
                                 message=&#34;pdflatex est nécessaire à la compilation des fichers\nVeuillez l&#39;installer avant de continuer&#34;)
        else:
            # création d&#39;un pop-up dans le cas où c&#39;est le dernier pdf générer
            list_of_files = glob.glob(r&#34;SGBD/utilisateurs/&#34; + self.auteur + &#34;/temp/*.pdf&#34;)
            latest_file = max(list_of_files, key=os.path.getctime)
            if latest_file == &#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.pdf&#34;:
                messagebox.showinfo(title=&#34;Veuillez patienter, compilation en cours&#34;,
                                    message=&#34;La prévisualisation s&#39;ouvrira d&#39;elle même&#34;)

            os.remove(f&#34;{nom}_{prenom}.aux&#34;)
            os.remove(f&#34;{nom}_{prenom}.log&#34;)
            os.remove(f&#34;{nom}_{prenom}.out&#34;)
            self.open_file(&#34;SGBD/utilisateurs/&#34;+self.auteur+&#34;/temp/&#34;+nom+&#34;_&#34;+prenom+&#34;.pdf&#34;)</code></pre>
</details>
</dd>
<dt id="Kholibri.Classes.MyThread.myThread.WriteInLog"><code class="name flex">
<span>def <span class="ident">WriteInLog</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def WriteInLog(self):
    logText = self.logWindow.winfo_children()[0]
    finishButton = self.logWindow.winfo_children()[1]
    for line in iter(self.pipeReader.readline, &#39;&#39;):
        logText.configure(state=&#39;normal&#39;,fg=&#39;red&#39;)
        logText.insert(&#39;end&#39;, line)
        logText.see(&#39;end&#39;)
        logText.configure(state=&#39;disabled&#39;)
    self.pipeReader.close()
    finishButton.configure(command=self.logWindow.destroy, state=&#39;normal&#39;)</code></pre>
</details>
</dd>
<dt id="Kholibri.Classes.MyThread.myThread.creation_temp"><code class="name flex">
<span>def <span class="ident">creation_temp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def creation_temp(self):
    try:
        if not os.path.exists(&#34;temp&#34;):
            os.makedirs(&#39;temp&#39;)
    except:
        messagebox.showerror(&#34;Impossible de créer le dossier temp. Essayez de créer un dossier temp.&#34;)
        return</code></pre>
</details>
</dd>
<dt id="Kholibri.Classes.MyThread.myThread.fileno"><code class="name flex">
<span>def <span class="ident">fileno</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the write file descriptor of the pipe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fileno(self):
    &#34;&#34;&#34;Return the write file descriptor of the pipe
  &#34;&#34;&#34;
    return self.fdWrite</code></pre>
</details>
</dd>
<dt id="Kholibri.Classes.MyThread.myThread.on_closing"><code class="name flex">
<span>def <span class="ident">on_closing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_closing(self):
    try:
        shutil.rmtree(&#39;./temp&#39;, ignore_errors=True)
    except:
        print(&#34;Impossible de supprimer le dossier temp.&#34;)
    self.application.destroy()
    exit()</code></pre>
</details>
</dd>
<dt id="Kholibri.Classes.MyThread.myThread.open_file"><code class="name flex">
<span>def <span class="ident">open_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_file(self, filename):
    if &#34;win&#34; in sys.platform.lower():
        os.startfile(filename)
    else:
        opener = &#34;open&#34; if sys.platform == &#34;darwin&#34; else &#34;xdg-open&#34;
        subprocess.call([opener, filename])</code></pre>
</details>
</dd>
<dt id="Kholibri.Classes.MyThread.myThread.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>méthode qui est appelée pour lancer un thread
elle s'occupe de renvoyer vers la bonne méthode selon le nom du thread</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    méthode qui est appelée pour lancer un thread
    elle s&#39;occupe de renvoyer vers la bonne méthode selon le nom du thread
    &#34;&#34;&#34;

    if self.name == &#34;ThreadAppli&#34;:
        self.application = ApplicationViews()
        self.creation_temp()
        self.application.protocol(&#34;WM_DELETE_WINDOW&#34;, self.on_closing)
        self.application.mainloop()
    if self.name == &#34;ThreadPreVisualisationStyle&#34;:
        self.PrevisualisationStyle()
    if self.name == &#34;ThreadPrevisualisationFeuille&#34;:
        self.PrevisualtisationFeuille()
    if self.name == &#34;ThreadLogCompilation&#34;:
        self.LogCompilation()
    if self.name == &#34;WriteInLog&#34;:
        self.WriteInLog()
    if self.name == &#34;ThreadPrevisualisationExo&#34;:
        self.PrevisualisationExo()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Kholibri.Classes" href="index.html">Kholibri.Classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Kholibri.Classes.MyThread.myThread" href="#Kholibri.Classes.MyThread.myThread">myThread</a></code></h4>
<ul class="">
<li><code><a title="Kholibri.Classes.MyThread.myThread.LogCompilation" href="#Kholibri.Classes.MyThread.myThread.LogCompilation">LogCompilation</a></code></li>
<li><code><a title="Kholibri.Classes.MyThread.myThread.PrevisualisationExo" href="#Kholibri.Classes.MyThread.myThread.PrevisualisationExo">PrevisualisationExo</a></code></li>
<li><code><a title="Kholibri.Classes.MyThread.myThread.PrevisualisationStyle" href="#Kholibri.Classes.MyThread.myThread.PrevisualisationStyle">PrevisualisationStyle</a></code></li>
<li><code><a title="Kholibri.Classes.MyThread.myThread.PrevisualtisationFeuille" href="#Kholibri.Classes.MyThread.myThread.PrevisualtisationFeuille">PrevisualtisationFeuille</a></code></li>
<li><code><a title="Kholibri.Classes.MyThread.myThread.WriteInLog" href="#Kholibri.Classes.MyThread.myThread.WriteInLog">WriteInLog</a></code></li>
<li><code><a title="Kholibri.Classes.MyThread.myThread.creation_temp" href="#Kholibri.Classes.MyThread.myThread.creation_temp">creation_temp</a></code></li>
<li><code><a title="Kholibri.Classes.MyThread.myThread.fileno" href="#Kholibri.Classes.MyThread.myThread.fileno">fileno</a></code></li>
<li><code><a title="Kholibri.Classes.MyThread.myThread.on_closing" href="#Kholibri.Classes.MyThread.myThread.on_closing">on_closing</a></code></li>
<li><code><a title="Kholibri.Classes.MyThread.myThread.open_file" href="#Kholibri.Classes.MyThread.myThread.open_file">open_file</a></code></li>
<li><code><a title="Kholibri.Classes.MyThread.myThread.run" href="#Kholibri.Classes.MyThread.myThread.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>